<!DOCTYPE html>
<html lang="zh-CN">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="fangminx" />



<meta name="description" content="java并行基础走进并行世界1.同步（Synchronous）和异步（Asynchronous）123451.同步和异步通常用来形容一次方法调用2.同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。3.异步方法调用一旦开始，方法调用就会立即返回，调用者可以继续后续的操作。4.如果异步调用需要返回结果，当异步调用真实完成时，则会通知调用者。5.同步可比作去商场购物，异步比作网购">
<meta name="keywords" content="博客重构,读书笔记,并发">
<meta property="og:type" content="article">
<meta property="og:title" content="【Java高并发程序设计】">
<meta property="og:url" content="http://yoursite.com/2017/03/12/【Java高并发程序设计】/index.html">
<meta property="og:site_name" content="Just For Fun！">
<meta property="og:description" content="java并行基础走进并行世界1.同步（Synchronous）和异步（Asynchronous）123451.同步和异步通常用来形容一次方法调用2.同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。3.异步方法调用一旦开始，方法调用就会立即返回，调用者可以继续后续的操作。4.如果异步调用需要返回结果，当异步调用真实完成时，则会通知调用者。5.同步可比作去商场购物，异步比作网购">
<meta property="og:updated_time" content="2018-03-04T03:02:21.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【Java高并发程序设计】">
<meta name="twitter:description" content="java并行基础走进并行世界1.同步（Synchronous）和异步（Asynchronous）123451.同步和异步通常用来形容一次方法调用2.同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。3.异步方法调用一旦开始，方法调用就会立即返回，调用者可以继续后续的操作。4.如果异步调用需要返回结果，当异步调用真实完成时，则会通知调用者。5.同步可比作去商场购物，异步比作网购">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Just For Fun！" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>【Java高并发程序设计】 | Just For Fun！</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: undefined
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">fangminx</a></h1>
        </hgroup>

        
        <p class="header-subtitle">就是为了好玩！</p>
        

        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="#" title="Email"></a>
                            
                                <a class="fa 新浪微博" href="#" title="新浪微博"></a>
                            
                                <a class="fa GitHub" href="https://github.com/fangminx" title="GitHub"></a>
                            
                                <a class="fa V2EX" href="#" title="V2EX"></a>
                            
                                <a class="fa 知乎" href="#" title="知乎"></a>
                            
                                <a class="fa Facebook" href="#" title="Facebook"></a>
                            
                                <a class="fa Google" href="#" title="Google"></a>
                            
                                <a class="fa Twitter" href="#" title="Twitter"></a>
                            
                                <a class="fa QQ" href="#" title="QQ"></a>
                            
                                <a class="fa 微信" href="#" title="微信"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java8/">Java8</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java基础/">Java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Solr/">Solr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elasticsearch/">elasticsearch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客重构/">博客重构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安装配置/">安装配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发/">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/牛客网/">牛客网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔试题/">笔试题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简单数据结构/">简单数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简单算法/">简单算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/虚拟机/">虚拟机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">来源</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">就是为了好玩！</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">fangminx</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">fangminx</a></h1>
            </hgroup>
            
            <p class="header-subtitle">就是为了好玩！</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="#" title="Email"></a>
                            
                                <a class="fa 新浪微博" target="_blank" href="#" title="新浪微博"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/fangminx" title="GitHub"></a>
                            
                                <a class="fa V2EX" target="_blank" href="#" title="V2EX"></a>
                            
                                <a class="fa 知乎" target="_blank" href="#" title="知乎"></a>
                            
                                <a class="fa Facebook" target="_blank" href="#" title="Facebook"></a>
                            
                                <a class="fa Google" target="_blank" href="#" title="Google"></a>
                            
                                <a class="fa Twitter" target="_blank" href="#" title="Twitter"></a>
                            
                                <a class="fa QQ" target="_blank" href="#" title="QQ"></a>
                            
                                <a class="fa 微信" target="_blank" href="#" title="微信"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-【Java高并发程序设计】" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/12/【Java高并发程序设计】/" class="article-date">
      <time datetime="2017-03-12T07:09:03.000Z" itemprop="datePublished">2017-03-12</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      【Java高并发程序设计】
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/博客重构/">博客重构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/读书笔记/">读书笔记</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="java并行基础"><a href="#java并行基础" class="headerlink" title="java并行基础"></a>java并行基础</h1><h2 id="走进并行世界"><a href="#走进并行世界" class="headerlink" title="走进并行世界"></a>走进并行世界</h2><h3 id="1-同步（Synchronous）和异步（Asynchronous）"><a href="#1-同步（Synchronous）和异步（Asynchronous）" class="headerlink" title="1.同步（Synchronous）和异步（Asynchronous）"></a>1.同步（Synchronous）和异步（Asynchronous）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.同步和异步通常用来形容一次方法调用</div><div class="line">2.同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。</div><div class="line">3.异步方法调用一旦开始，方法调用就会立即返回，调用者可以继续后续的操作。</div><div class="line">4.如果异步调用需要返回结果，当异步调用真实完成时，则会通知调用者。</div><div class="line">5.同步可比作去商场购物，异步比作网购，网购支付完成在等送货上门时，可以做任何事情。</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="2-并发（Concurrency）和并行（Parallelism）"><a href="#2-并发（Concurrency）和并行（Parallelism）" class="headerlink" title="2.并发（Concurrency）和并行（Parallelism）"></a>2.并发（Concurrency）和并行（Parallelism）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1.并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。</div><div class="line">2.并行是真正意义上的“同时执行”。</div></pre></td></tr></table></figure>
<h3 id="3-临界区"><a href="#3-临界区" class="headerlink" title="3.临界区"></a>3.临界区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">用来表示一种公共资源或者共享数据，可以被多个线程使用，但每一次，只能有一个线程使用它。</div></pre></td></tr></table></figure>
<h3 id="4-阻塞（Blocking）和非阻塞（Non-Blocking）"><a href="#4-阻塞（Blocking）和非阻塞（Non-Blocking）" class="headerlink" title="4.阻塞（Blocking）和非阻塞（Non-Blocking）"></a>4.阻塞（Blocking）和非阻塞（Non-Blocking）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.形容多线程建的相互影响，如果一个线程占用了临界区资源，其他所有需要这个资源的线程就必须在</div><div class="line">这个临界区中进行等待</div><div class="line">   </div><div class="line">2.等待会导致线程挂起，这种情况就是阻塞。</div><div class="line">   </div><div class="line">3.如果占用资源的线程一直不愿意释放资源，其他所有阻塞在这个临界区上的线程都不能工作</div></pre></td></tr></table></figure>
<h3 id="5-死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）"><a href="#5-死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）" class="headerlink" title="5.死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）"></a>5.死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.都属于多线程的活跃性问题，如果出现上述几种情况，线程可能不再活跃</div><div class="line">   </div><div class="line">2.饥饿，比如它的线程优先级可能太低，高优先级的线程不断抢占它需要的资源，导致其无法工作，</div><div class="line">可能在未来一段时间内解决（高优先级线程已经完成任务）</div><div class="line">   </div><div class="line">3.活锁，资源不断在两个线程中跳动，没有一个线程可以同时拿到所有资源而正常执行</div></pre></td></tr></table></figure>
<h3 id="6-并发级别"><a href="#6-并发级别" class="headerlink" title="6.并发级别"></a>6.并发级别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0.分为：阻塞、无饥饿、无障碍、无锁、无等待</div><div class="line">   </div><div class="line">1.阻塞：一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法继续执行</div><div class="line">2.无饥饿：如果锁是公平的，满足先来后到，那么饥饿就不会产生</div><div class="line">3.无障碍：线程可以同时访问临界区，为确保数据安全，如果有数据竞争，立即对修改数据进行回滚</div><div class="line">4.无锁：无所的并行总能保证有一个线程在有限步是可以胜出的。</div><div class="line">5.无等待：要求所有线程必须在有限步内完成。</div></pre></td></tr></table></figure>
<h3 id="有关并行的两个重要定律"><a href="#有关并行的两个重要定律" class="headerlink" title="有关并行的两个重要定律"></a>有关并行的两个重要定律</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.Amdahl定律：加速比定义，加速比=优化前系统耗时/优化后系统耗时，</div><div class="line">取决于CPU数量增加和串行化程序的减少</div><div class="line">   </div><div class="line">2.Gustafson定律：如果串行化比例很小，加速比就是处理器的个数（加速比定义都一样）</div></pre></td></tr></table></figure>
<h3 id="java的内存模型（JMM）"><a href="#java的内存模型（JMM）" class="headerlink" title="java的内存模型（JMM）"></a>java的内存模型（JMM）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.原子性：一个操作是不可中断的</div><div class="line">   		</div><div class="line">2.可见性：当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改</div><div class="line">   </div><div class="line">3.有序性：在并发时，程序的执行可能就会出现乱序</div></pre></td></tr></table></figure>
<hr>
<h2 id="Java并行程序基础"><a href="#Java并行程序基础" class="headerlink" title="Java并行程序基础"></a>Java并行程序基础</h2><h3 id="1-线程的基本操作"><a href="#1-线程的基本操作" class="headerlink" title="1.线程的基本操作"></a>1.线程的基本操作</h3><ul>
<li>新建线程：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.Thread子类重写run方法，调用Thread子类对象的start方法</div><div class="line">   </div><div class="line">2.创建Thread类带Runnable接口参数的构造器对象，参数对象重写了run方法，调用Thread类对象的start方法</div></pre></td></tr></table></figure>
<ul>
<li>终止线程：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stop方法，太暴力，已过时，可能引起数据不一致的问题</div></pre></td></tr></table></figure>
<ul>
<li>线程中断：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1.Thread.interrupt()它通知目标线程中断</div><div class="line">   </div><div class="line">2.Thread.isInterrupted()方法判断当前线程是否有被中断（通过检查中断标志位）</div><div class="line">   </div><div class="line">3.静态方法Thread.interrupted()判断当前线程的中断状态（同时清除当前线程的中断标志位状态）</div><div class="line">   </div><div class="line">4.通过判断线程是否被中断了，如果是，手动退出循环体（break;），否则中断后的线程还可以继续执行。</div></pre></td></tr></table></figure>
<ul>
<li>等待（wait）和通知（notify）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1.这两个方法在Object类，任何对象都可以调用者两个方法</div><div class="line">   </div><div class="line">2.如果一个线程调用了wait，它就会进入等待队列，在这个等待队列中，可能有多个等待线程</div><div class="line">   </div><div class="line">3.当调用notify，它就会从等待队列中，随机选择一个线程，并将其唤醒</div><div class="line">   </div><div class="line">4.notifyAll方法唤醒等待队列中的所有等待线程</div><div class="line">   </div><div class="line">5.wait方法必须包含在对应的synchronized语句中</div></pre></td></tr></table></figure>
<ul>
<li>挂起(suspend)和继续执行(resume)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.已过时</div><div class="line">2.suspend在导致线程暂停的同时，并不会去释放任何锁资源</div><div class="line">3.如果resume操作意外地在suspend前执行，可能导致整个系统工作不正常</div></pre></td></tr></table></figure>
<ul>
<li>等待线程结束(join)和谦让(yield)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.join不带参数，表示无限等待，一直阻塞调用者（当前线程），直到目标线程执行完毕</div><div class="line">2.join带参数，表示最大等待时间，如果指定时间目标线程还在执行，当前线程往下执行</div><div class="line">3.yield是静态方法，使当前线程让出CPU，但还会进行CPU资源的争夺</div></pre></td></tr></table></figure>
<h3 id="2-volatile与Java内存模型-JMM"><a href="#2-volatile与Java内存模型-JMM" class="headerlink" title="2.volatile与Java内存模型(JMM)"></a>2.volatile与Java内存模型(JMM)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1.为了在适当的场合，确保线程间的有序性、可见性、原子性，java提供了volatile关键字</div><div class="line">2.如果不使用volatile申明变量，这个变量被修改后，其他线程可能不会被通知</div></pre></td></tr></table></figure>
<h3 id="3-线程组"><a href="#3-线程组" class="headerlink" title="3.线程组"></a>3.线程组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.Thread t1 = new Thread(new ThreadGroup(),new ThreadGroupName(),&quot;T1&quot;)</div><div class="line">   </div><div class="line">2.第一个参数，线程组对象（jdk自带），多个线程可共用一个线程组对象</div><div class="line">3.第二个参数，自定义实现Runnable接口的线程类</div><div class="line">4.第三个参数，线程组中某个线程的自定义名称</div><div class="line">5.调用线程组对象的list方法，可以打印这个线程组中所有线程信息，stop方法，立刻关闭线程组所有线程</div></pre></td></tr></table></figure>
<h3 id="4-守护线程（Daemon）"><a href="#4-守护线程（Daemon）" class="headerlink" title="4.守护线程（Daemon）"></a>4.守护线程（Daemon）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.守护线程必须在start()之前设置，setDaemon(true)</div><div class="line">   </div><div class="line">2.守护线程在用户线程中设置（如main用户线程），如果用户线程全部结束，守护线程要守护的对象已经不存在了</div><div class="line">   </div><div class="line">3.在一个Java应用中，只有守护线程时，Java虚拟机就会自然退出</div></pre></td></tr></table></figure>
<h3 id="5-线程优先级"><a href="#5-线程优先级" class="headerlink" title="5.线程优先级"></a>5.线程优先级</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1.数字越大优先级越高（1-10）</div><div class="line">2.setPriority（Thread.MAX_PRIORITY）</div></pre></td></tr></table></figure>
<h3 id="6-线程安全的概念与synchronized"><a href="#6-线程安全的概念与synchronized" class="headerlink" title="6.线程安全的概念与synchronized"></a>6.线程安全的概念与synchronized</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.volatile并不能真正保证线程安全，它只能确保一个线程修改了数据后，其他线程能够看到这个改动</div><div class="line">2.synchronized代码块，要指定锁对象</div><div class="line">3.synchronized作用于实例方法，锁对象是当前类的对象</div><div class="line">4.synchronized作用于静态方法，锁对象是当前类的字节码对象</div></pre></td></tr></table></figure>
<h3 id="7-隐蔽的错误"><a href="#7-隐蔽的错误" class="headerlink" title="7.隐蔽的错误"></a>7.隐蔽的错误</h3><ul>
<li>并发下的ArrayList</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">t1和t2两个线程同时向一个ArrayList容器中添加元素:</div><div class="line">   </div><div class="line">1.第一种结果，程序正常结束，大小正好为添加的元素</div><div class="line">2.程序抛出异常，ArrayList在扩容过程中，内部一致性被破坏，另外一个线程访问到了不一致的内部状态，</div><div class="line">出现越界问题</div><div class="line">3.打印的大小小于添加的元素，两个线程同时对ArrayList中的同一个位置进行赋值导致的</div></pre></td></tr></table></figure>
<ul>
<li>并发下的HashMap</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">t1和t2线程同时对HashMap进行put操作:</div><div class="line">   </div><div class="line">1.第一种情况，程序正常，大小正常</div><div class="line">2.第二种情况，程序正常，大小偏小</div><div class="line">3.第三种情况，程序永远无法结束，hashMap元素结构是链表，链表结构在多线程环境下变成环</div><div class="line">（key1、key2的next指针互相指向对方），迭代条件是&#123;当前元素不为null，当前元素的next赋给当前元素&#125;</div><div class="line">&#123;这条件可以保证put方法一直从尾部添加元素&#125;</div></pre></td></tr></table></figure>
<ul>
<li>错误的加锁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">锁对象应该是不变的</div></pre></td></tr></table></figure>
<h1 id="JDK并发包"><a href="#JDK并发包" class="headerlink" title="JDK并发包"></a>JDK并发包</h1><h2 id="synchronized的功能扩展：重入锁"><a href="#synchronized的功能扩展：重入锁" class="headerlink" title="synchronized的功能扩展：重入锁"></a>synchronized的功能扩展：重入锁</h2><h3 id="1-重入锁-使用java-util-concurrent-lock-ReentrantLock类来实现"><a href="#1-重入锁-使用java-util-concurrent-lock-ReentrantLock类来实现" class="headerlink" title="1.重入锁,使用java.util.concurrent.lock.ReentrantLock类来实现"></a>1.重入锁,使用java.util.concurrent.lock.ReentrantLock类来实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.<span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"><span class="number">2</span>.lock.lock();和lock.unlock();保护临界区资源</div><div class="line"><span class="number">3</span>.允许迭代</div></pre></td></tr></table></figure>
<h3 id="2-中断响应"><a href="#2-中断响应" class="headerlink" title="2.中断响应"></a>2.中断响应</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.对锁的请求，统一使用lockInterruptibly()</div><div class="line">   </div><div class="line">2.线程1先请求锁1，后请求锁2，线程2先请求锁2，后请求锁1，很容易形成线程的相互等待</div><div class="line">   </div><div class="line">3.线程2调用interrupt(),放弃对锁1的申请，同时释放已获得的锁2，这个操作可以使线程1顺利得到锁2</div><div class="line">而继续执行</div></pre></td></tr></table></figure>
<h3 id="3-锁申请等待限时"><a href="#3-锁申请等待限时" class="headerlink" title="3.锁申请等待限时"></a>3.锁申请等待限时</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.为避免死锁，给定一个等待时间，让线程自动放弃，使用tryLock()</div><div class="line">   </div><div class="line">2.lock.tryLock(5,TimeUnit.SECONDS),参数1表示等待时长，参数2表示计时单位，得到锁返回true，</div><div class="line">否则false</div><div class="line">    </div><div class="line">3.不带参数直接运行，申请成功，立即返回true，锁被其他线程占用，立即返回false</div></pre></td></tr></table></figure>
<h3 id="4-公平锁"><a href="#4-公平锁" class="headerlink" title="4.公平锁"></a>4.公平锁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.不会产生饥饿现象，按照时间的先后顺序（使用synchronized控制锁，是非公平的）</div><div class="line">    </div><div class="line">2.重入锁有构造：public ReentrantLock(boolean fair),当fair为true，表示锁是公平的</div><div class="line">    </div><div class="line">3.性能低，可以交替执行线程</div></pre></td></tr></table></figure>
<h2 id="重入锁的Condition条件"><a href="#重入锁的Condition条件" class="headerlink" title="重入锁的Condition条件"></a>重入锁的Condition条件</h2><h3 id="1-Condition接口提供方法"><a href="#1-Condition接口提供方法" class="headerlink" title="1.Condition接口提供方法"></a>1.Condition接口提供方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.await()方法使当前线程等待，同时释放当前锁，其他线程使用signal()或signalAll()方法时，</div><div class="line">有机会获得锁继续执行。当前线程被中断，能跳出等待。</div><div class="line">   </div><div class="line">2.awaitUninterruptibly()不会再等待过程中响应中断</div><div class="line">   </div><div class="line">3.signal()唤醒一个等待中的线程</div></pre></td></tr></table></figure>
<h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Condition condition = lock.newCondition();</div></pre></td></tr></table></figure>
<h2 id="允许多个线程同时访问：信号量（Semaphore）"><a href="#允许多个线程同时访问：信号量（Semaphore）" class="headerlink" title="允许多个线程同时访问：信号量（Semaphore）"></a>允许多个线程同时访问：信号量（Semaphore）</h2><h3 id="1-构造信号量对象时，必须指定信号量的准入数，可以指定是否公平"><a href="#1-构造信号量对象时，必须指定信号量的准入数，可以指定是否公平" class="headerlink" title="1.构造信号量对象时，必须指定信号量的准入数，可以指定是否公平"></a>1.构造信号量对象时，必须指定信号量的准入数，可以指定是否公平</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span></span></div><div class="line"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span></div></pre></td></tr></table></figure>
<h3 id="2-主要逻辑方法"><a href="#2-主要逻辑方法" class="headerlink" title="2.主要逻辑方法"></a>2.主要逻辑方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span>尝试获得一个准入的许可，否则线程会等待，直到有线程释放一个许可或者当前线程被中断</span></div><div class="line">   </div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span> 不响应中断</div><div class="line">   </div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout,TimeUnit unit)</span></div><div class="line">尝试获得一个许可，成功返回<span class="keyword">true</span>，否则返回<span class="keyword">false</span></div><div class="line">   </div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span>用于线程访问资源结束后，释放一个许可，以使其他等待许可的线程可以进行资源访问</div></pre></td></tr></table></figure>
<h3 id="3-信号量的泄露"><a href="#3-信号量的泄露" class="headerlink" title="3.信号量的泄露"></a>3.信号量的泄露</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">如果发生了信号量的泄露（申请了但没有释放），那么可以进入临界区的线程数量越来越少，直到所有线程均不可访问</div></pre></td></tr></table></figure>
<h2 id="ReadWriteLock读写锁"><a href="#ReadWriteLock读写锁" class="headerlink" title="ReadWriteLock读写锁"></a>ReadWriteLock读写锁</h2><ul>
<li>读-读之间不互斥，不阻塞，不对数据的完整性造成破坏，可以并行操作</li>
<li>如果在系统中，读操作次数远远大于写操作，则读写锁就可以发挥最大功效</li>
<li>代码（当前类由线程类加载）<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//成员</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Lock readLock = readWriteLock.readLock();</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Lock writeLock = readWriteLock.writeLock();</div><div class="line">						</div><div class="line"><span class="comment">//模拟读操作</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">handleRead</span><span class="params">(Lock lock)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">	<span class="keyword">try</span>&#123;</div><div class="line">		lock.lock();<span class="comment">//传入读锁</span></div><div class="line">		Thread.sleep(<span class="number">1000</span>);<span class="comment">//模拟耗时的操作，读操作线程越多，读写锁优势越明显</span></div><div class="line">	&#125;<span class="keyword">finally</span>&#123;</div><div class="line">		lock.unlock();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="倒计时器CountDownLatch"><a href="#倒计时器CountDownLatch" class="headerlink" title="倒计时器CountDownLatch"></a>倒计时器CountDownLatch</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行</div></pre></td></tr></table></figure>
<h2 id="循环栅栏：CyclicBarrier"><a href="#循环栅栏：CyclicBarrier" class="headerlink" title="循环栅栏：CyclicBarrier"></a>循环栅栏：CyclicBarrier</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">功能比CountDownLatch更复杂</div></pre></td></tr></table></figure>
<h2 id="线程阻塞工具类：LockSupport"><a href="#线程阻塞工具类：LockSupport" class="headerlink" title="线程阻塞工具类：LockSupport"></a>线程阻塞工具类：LockSupport</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1.可以在线程内任意位置让线程阻塞</div><div class="line">2.LockSupport的静态方法park()可以阻塞当前线程...</div></pre></td></tr></table></figure>
<h2 id="线程复用：线程池"><a href="#线程复用：线程池" class="headerlink" title="线程复用：线程池"></a>线程复用：线程池</h2><h3 id="1-Executor框架"><a href="#1-Executor框架" class="headerlink" title="1.Executor框架"></a>1.Executor框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//各种类型的线程池，主要有以下工厂方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span>,</span></div><div class="line">返回一个固定线程数量的线程池，新任务提交时线程池若无空闲线程，暂存在任务队列</div><div class="line">   </div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span>,返回只有一个线程的线程池</div><div class="line">   </div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span>,返回一个可根据实际情况调整线程数量的线程池</div><div class="line">    </div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span>，</div><div class="line">返回一个扩展了ExecutorService接口的接口对象，扩展了给定时间执行某任务的功能，如，延时执行，周期执行</div><div class="line">   </div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></div><div class="line">同上，可指定线程池线程数量（线程池大小为1）</div><div class="line">						</div><div class="line"><span class="comment">//内部实现：均使用了ThreadPoolExecutor实现(传入不同参数)</span></div><div class="line">1.corePoolSize:指定线程池中的线程数量</div><div class="line">2.maximumPoolSize:指定了线程池中的最大线程数量</div><div class="line">3.keepAliveTime:超过corePoolSize的空闲线程，多久会被销毁</div><div class="line">4.unit：keepAliveTime的单位</div><div class="line">5.workQueue：任务队列，被提交但尚未执行的任务</div><div class="line">6.threadFactory:线程工厂，一般用默认</div><div class="line">7.handler:拒绝策略,当任务太多来不及处理，如何拒绝任务（有界队列达到了上限，或使用了</div><div class="line">SynchronousQueue会将任务直接提交给线程池，提交失败，执行拒绝策略）</div></pre></td></tr></table></figure>
<h3 id="2-拒绝策略"><a href="#2-拒绝策略" class="headerlink" title="2.拒绝策略"></a>2.拒绝策略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.AbortPolicy策略：直接抛出异常，阻止系统正常工作</div><div class="line">2.CallerRunsPolicy策略：该策略直接在调用者线程中，运行当前被丢弃的任务</div><div class="line">3.DiscardOledestPolicy策略：丢弃最老的一个请求，尝试再次提交当前任务</div><div class="line">4.DiscardPolicy策略：不处理</div><div class="line">5.自己扩展RejectedExecutionHandler接口</div></pre></td></tr></table></figure>
<h2 id="自定义线程创建：ThreadFactory"><a href="#自定义线程创建：ThreadFactory" class="headerlink" title="自定义线程创建：ThreadFactory"></a>自定义线程创建：ThreadFactory</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">第6个参数，可以跟踪线程池何时创建、线程名称、组、优先级等</div></pre></td></tr></table></figure>
<h2 id="扩展线程池"><a href="#扩展线程池" class="headerlink" title="扩展线程池"></a>扩展线程池</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ThreadPoolExecutor提供了beforeExecute()、afterExecute()、terminated()三个接口对线程池进行控制，</div><div class="line">在创建ThreadPoolExecutor类对象时重写这些方法</div></pre></td></tr></table></figure>
<h2 id="JDK并发容器"><a href="#JDK并发容器" class="headerlink" title="JDK并发容器"></a>JDK并发容器</h2><h3 id="1-并发集合简介"><a href="#1-并发集合简介" class="headerlink" title="1.并发集合简介"></a>1.并发集合简介</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ConcurrentHashMap:线程安全的HashMap</div><div class="line">CopyOnWriteArrayList:适用在读多写少的场合</div><div class="line">ConcurrentLinkedQueue:适用链表实现，可以看做线程安全的LnkedList</div><div class="line">BlockingQueue:表示阻塞队列，适用于数据共享的通道</div><div class="line">ConcurrentSkipListMap：跳表的实现，使用跳表的数据结构进行快速查找，跳表遍历输出是有序的</div></pre></td></tr></table></figure>
<h3 id="2-线程安全的HashMap"><a href="#2-线程安全的HashMap" class="headerlink" title="2.线程安全的HashMap"></a>2.线程安全的HashMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map m = Collections.synchronizedMap(<span class="keyword">new</span> HashMap()),在多线程环境中性能表现不算好</div><div class="line">   </div><div class="line">java.util.concurrent.ConcurrentHashMap,专为并发进行了性能优化，更适用多线程的场合</div></pre></td></tr></table></figure>
<h3 id="3-线程安全的List"><a href="#3-线程安全的List" class="headerlink" title="3.线程安全的List"></a>3.线程安全的List</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1.ArrayList和Vector都使用数组做为其内部实现，Vector是线程安全的，ArrayList不是</div><div class="line">   </div><div class="line">2.LinkedList使用链表的数据结构实现，并不是线程安全的</div><div class="line">   </div><div class="line">3.包装成线程安全的List:</div><div class="line">public static List&lt;String&gt; list = Collections.synchronizedList(new LinkedList&lt;String&gt;());</div></pre></td></tr></table></figure>
<h3 id="4-高效读写队列"><a href="#4-高效读写队列" class="headerlink" title="4.高效读写队列"></a>4.高效读写队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ConcurrentLinkedQueue:链表作为其数据结构</div></pre></td></tr></table></figure>
<h1 id="锁优化与并行模式"><a href="#锁优化与并行模式" class="headerlink" title="锁优化与并行模式"></a>锁优化与并行模式</h1><h2 id="有助于提高”锁”性能的几点建议"><a href="#有助于提高”锁”性能的几点建议" class="headerlink" title="有助于提高”锁”性能的几点建议"></a>有助于提高”锁”性能的几点建议</h2><h3 id="1-减少锁持有时间"><a href="#1-减少锁持有时间" class="headerlink" title="1.减少锁持有时间"></a>1.减少锁持有时间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</div><div class="line">	othercode1();</div><div class="line">	mutextMethod();</div><div class="line">	othercode2();</div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="comment">//假设只有mutextMethod()方法是有同步需要的，可改为：</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncMethod2</span><span class="params">()</span></span>&#123;</div><div class="line">	othercode1();</div><div class="line">	<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</div><div class="line">		mutextMethod();</div><div class="line">	&#125;</div><div class="line">	othercode2();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-减少锁粒度"><a href="#2-减少锁粒度" class="headerlink" title="2.减少锁粒度"></a>2.减少锁粒度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">典型使用场景：ConcurrentHashMap类的实现</div><div class="line">   </div><div class="line">对于HashMap，最重要的就是get和put方法，对整个HashMap加锁，加锁粒度太大</div><div class="line">它内部细分了若干个小的HashMap，称为段，默认细分为16个段</div><div class="line">只要被加入的（哈希）表项不存放在同一个段中，则线程间可以做到并行</div><div class="line">   </div><div class="line">但：当系统需要取得全局锁时，要获取所有子段的锁，消耗资源比较多</div><div class="line">   </div><div class="line">例：size方法会先使用无锁方式求和，失败后会尝试加锁方法求和，性能差与同步的HashMap</div></pre></td></tr></table></figure>
<h3 id="3-使用读写锁替换独占锁，之前介绍过，不再重复"><a href="#3-使用读写锁替换独占锁，之前介绍过，不再重复" class="headerlink" title="3.使用读写锁替换独占锁，之前介绍过，不再重复"></a>3.使用读写锁替换独占锁，之前介绍过，不再重复</h3><h3 id="4-锁分离"><a href="#4-锁分离" class="headerlink" title="4.锁分离"></a>4.锁分离</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">LinkedBlockingQueue实现中，take函数和put函数分别实现了从队列中取得数据和往队列中增加数据，</div><div class="line">分别作用于队列的前端和尾端，理论上不冲突</div><div class="line">    				</div><div class="line">JDK定义了takeLock和putLock，这样take和put函数相互独立，只需要在take和take间、put和put间分别对</div><div class="line">相应的锁进行竞争</div></pre></td></tr></table></figure>
<h3 id="5-锁粗化"><a href="#5-锁粗化" class="headerlink" title="5.锁粗化"></a>5.锁粗化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.为了保证有效并发，要求每个线程持有锁的时间尽量短，应尽快释放锁，但多次请求、同步和释放，</div><div class="line">其本身也会消耗资源，不利于优化</div><div class="line">    	 			</div><div class="line"><span class="number">2</span>.把所有锁的操作整合成对锁的一次请求，减少对锁的请求同步次数，这个操作叫做锁的粗化</div><div class="line">    </div><div class="line"><span class="number">3</span>.例</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;CIRCLE;i++)&#123;</div><div class="line">	<span class="keyword">synchronized</span>(lock)&#123;</div><div class="line">	</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//每次循环都有申请锁和释放锁的操作，应改写为：</span></div><div class="line"><span class="keyword">synchronized</span>(lock)&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;CIRCLE;i++)&#123;</div><div class="line">	</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Java虚拟机对锁优化所做的努力"><a href="#Java虚拟机对锁优化所做的努力" class="headerlink" title="Java虚拟机对锁优化所做的努力"></a>Java虚拟机对锁优化所做的努力</h2><h3 id="1-锁偏向"><a href="#1-锁偏向" class="headerlink" title="1.锁偏向"></a>1.锁偏向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">如果一个线程获得了锁，那么锁就进入偏向模式，当这个线程再次请求锁是，无须再做任何同步操作，</div><div class="line">但对于锁竞争比较激烈的场合，效果不佳</div></pre></td></tr></table></figure>
<h3 id="2-轻量级锁"><a href="#2-轻量级锁" class="headerlink" title="2.轻量级锁"></a>2.轻量级锁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">如果偏向锁失败，它还会将对象头作为指针，指向持有锁定的线程堆栈内部，判断其是否持有锁，如果获取失败，</div><div class="line">就会膨胀为重量级锁，成功，进入临界区</div></pre></td></tr></table></figure>
<h3 id="3-自旋锁"><a href="#3-自旋锁" class="headerlink" title="3.自旋锁"></a>3.自旋锁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">膨胀后的锁会经历若干次循环，如果还得不到锁，才会真实地将线程在操作系统层面挂起</div></pre></td></tr></table></figure>
<h3 id="4-锁消除"><a href="#4-锁消除" class="headerlink" title="4.锁消除"></a>4.锁消除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在没有用锁的地方使用锁，即使Vector，会使用逃逸分析技术观察某一个变量是否会逃出某一作用域</div></pre></td></tr></table></figure>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><ul>
<li>一个容器，保证容器对象只被当前线程访问</li>
<li>set方法相当于把数据存放在一个map中，map的key为当前线程</li>
<li>get方法先获得当前线程名，作为key获得其value</li>
<li>ThreadLocal变量，手动设置为null，其所有线程的局部变量都有可能被回收</li>
</ul>
<h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><h3 id="0-说明："><a href="#0-说明：" class="headerlink" title="0.说明："></a>0.说明：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">对于并发控制，锁是一种悲观策略，它总是假设每次临界区操作会产生冲突，必须每次操作都小心翼翼。</div><div class="line">无锁是一种乐观策略，遇到冲突采用比较交换技术（CAS Compare And Swap）来鉴别线程冲突，</div><div class="line">一旦检测冲突发生，就重试当前操作直到没有冲突为止</div></pre></td></tr></table></figure>
<h3 id="1-并发策略：比较交换（CAS）"><a href="#1-并发策略：比较交换（CAS）" class="headerlink" title="1.并发策略：比较交换（CAS）"></a>1.并发策略：比较交换（CAS）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当多个线程同时使用CAS操作一个变量时，只有一个会胜出，失败的线程不会被挂起，并且允许再次尝试</div></pre></td></tr></table></figure>
<h3 id="2-无锁的线程安全整数：Atomiclnteger"><a href="#2-无锁的线程安全整数：Atomiclnteger" class="headerlink" title="2.无锁的线程安全整数：Atomiclnteger"></a>2.无锁的线程安全整数：Atomiclnteger</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>.JDK并发包中有一个atomic包，最常用的类是AtomicInteger</div><div class="line">   			</div><div class="line"><span class="number">2</span>.incrementAndGet()方法使用CAS操作将自己加<span class="number">1</span>，同时返回当前值</div><div class="line">内部实现：</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">for</span>(;;)&#123;		<span class="comment">//使用死循环，CAS操作不成功的情况，就要进行不断尝试</span></div><div class="line">		<span class="keyword">int</span> current = get();</div><div class="line">		<span class="keyword">int</span> next = current + <span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span>(compareAndSet(current,next))	<span class="comment">//该方法将新值next写入，使得期望值等于新值，</span></div><div class="line">		                                <span class="comment">//否则前两行代码被其他线程修改过了</span></div><div class="line">		<span class="keyword">return</span> next;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-无锁的对象引用：AtomicReferencece"><a href="#3-无锁的对象引用：AtomicReferencece" class="headerlink" title="3.无锁的对象引用：AtomicReferencece"></a>3.无锁的对象引用：AtomicReferencece</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0.和AtomicInteger类似，是对普通对象的引用</div><div class="line">    </div><div class="line">1.无法解决反复修改，但最终值相同的情况</div><div class="line">2.解决上述情况，使用AtomicStampedReference</div></pre></td></tr></table></figure>
<h3 id="4-带有时间戳的对象引用：AtomicStampedReference"><a href="#4-带有时间戳的对象引用：AtomicStampedReference" class="headerlink" title="4.带有时间戳的对象引用：AtomicStampedReference"></a>4.带有时间戳的对象引用：AtomicStampedReference</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0.当对应数值被修改时，除了更新数据本身，还必须更新时间戳</div><div class="line">   </div><div class="line">1.设置对象值时，对象值以及时间戳都必须满足期望值，才可写入成功</div></pre></td></tr></table></figure>
<h3 id="5-无锁的数组：AtomicIntegerArray"><a href="#5-无锁的数组：AtomicIntegerArray" class="headerlink" title="5.无锁的数组：AtomicIntegerArray"></a>5.无锁的数组：AtomicIntegerArray</h3><h3 id="6-普通变量的原子操作"><a href="#6-普通变量的原子操作" class="headerlink" title="6.普通变量的原子操作"></a>6.普通变量的原子操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">分为int、long、普通对象的CAS修改：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、</div><div class="line">AtomicReferenceFieldUpdater</div></pre></td></tr></table></figure>
<h3 id="7-等待队列SynchronousQueue的实现"><a href="#7-等待队列SynchronousQueue的实现" class="headerlink" title="7.等待队列SynchronousQueue的实现"></a>7.等待队列SynchronousQueue的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">将put()和take()两个功能抽象为一个共通的方法Transferer.transfer()</div></pre></td></tr></table></figure>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ul>
<li>两个或多个线程，相互占用对方需要的资源，都不进行释放。</li>
<li>代码模拟</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//多人就餐问题，必须得到fork1，fork2两根筷子才能吃饭</span></div><div class="line"><span class="keyword">if</span>(tool == fork1)&#123;</div><div class="line">	<span class="keyword">synchronized</span>(fork1)&#123;</div><div class="line">		<span class="keyword">try</span>&#123;</div><div class="line">			Thread.sleep(<span class="number">500</span>);</div><div class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">synchronized</span>(fork2)&#123;</div><div class="line">			System.out.println(<span class="string">"A程序在执行。。。"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>cmd/jps命令得到java进程的进程ID，接着使用jstack命令得到线程的线程堆栈、</li>
</ul>
<hr>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="1-包含静态成员的单例："><a href="#1-包含静态成员的单例：" class="headerlink" title="1.包含静态成员的单例："></a>1.包含静态成员的单例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> STATUS = <span class="number">1</span>;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"Singleton is create"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">   </div><div class="line">在相同任何地方引用这个STATUS都会导致instance实例被创建（类第一次初始化时创建静态成员instance）</div><div class="line">   </div><div class="line">例：System.out.println(Singleton.STATUS);</div><div class="line">会打印：Singleton is create \n <span class="number">1</span></div></pre></td></tr></table></figure>
<h3 id="2-支持延迟加载的策略"><a href="#2-支持延迟加载的策略" class="headerlink" title="2.支持延迟加载的策略"></a>2.支持延迟加载的策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> LazySingleton&#123;</div><div class="line">		System.out.println(<span class="string">"LazySingleton is create"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(instance==<span class="keyword">null</span>)</div><div class="line">			instance = <span class="keyword">new</span> LazySingleton();</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">   </div><div class="line">当getInstance()方法被第一次调用时，创建单例对象</div></pre></td></tr></table></figure>
<h3 id="3-无锁"><a href="#3-无锁" class="headerlink" title="3.无锁"></a>3.无锁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class StaticSingleton&#123;</div><div class="line">	private StaticSingleton()&#123;</div><div class="line">		System.out.println(&quot;StaticSingleton is create&quot;);</div><div class="line">	&#125;</div><div class="line">	private static class SingletonHolder&#123;</div><div class="line">		private static StaticSingleton instance = new StaticSingleton();</div><div class="line">	&#125;</div><div class="line">	public static StaticSingleton getInstance()&#123;</div><div class="line">		return SingletonHolder.instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">   </div><div class="line">只有在getInstance方法被第一次调用时，StaticSingleton的实例才会被创建</div><div class="line">   </div><div class="line">内部类声明为private，不能在外部访问并初始化它，利用虚拟机的类初始化机制创建单例</div></pre></td></tr></table></figure>
<h2 id="不变模式"><a href="#不变模式" class="headerlink" title="不变模式"></a>不变模式</h2><h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">一个对象一旦被创建，它的内部状态将永远不会发生改变，没有一个线程可以修改其内部状态和数据，</div><div class="line">内部状态也不会自行改变，不需要同步控制</div></pre></td></tr></table></figure>
<h3 id="2-只需注意"><a href="#2-只需注意" class="headerlink" title="2.只需注意"></a>2.只需注意</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.去除setter方法以及所有修改自身属性的方法</div><div class="line">2.将所有属性设置为私有，并用final标记</div><div class="line">3.确保没有子类可以修改它的行为</div><div class="line">4.有一个可以创建完整对象的构造函数</div></pre></td></tr></table></figure>
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2017/03/12/【Java高并发程序设计】/">【Java高并发程序设计】</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">fangminx</a></p>
        <p><span>发布时间:</span>2017-03-12, 15:09:03</p>
        <p><span>最后更新:</span>2018-03-04, 11:02:21</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2017/03/12/【Java高并发程序设计】/" title="【Java高并发程序设计】">http://yoursite.com/2017/03/12/【Java高并发程序设计】/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2017/03/12/【Java高并发程序设计】/　　作者: fangminx" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2017/03/12/【深入浅出MySQL】/">
                    【深入浅出MySQL】
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2017/03/11/Java简单IO流操作/">
                    Java简单IO流操作
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#java并行基础"><span class="toc-number">1.</span> <span class="toc-text">java并行基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#走进并行世界"><span class="toc-number">1.1.</span> <span class="toc-text">走进并行世界</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-同步（Synchronous）和异步（Asynchronous）"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.同步（Synchronous）和异步（Asynchronous）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-并发（Concurrency）和并行（Parallelism）"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.并发（Concurrency）和并行（Parallelism）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-临界区"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.临界区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-阻塞（Blocking）和非阻塞（Non-Blocking）"><span class="toc-number">1.1.4.</span> <span class="toc-text">4.阻塞（Blocking）和非阻塞（Non-Blocking）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）"><span class="toc-number">1.1.5.</span> <span class="toc-text">5.死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-并发级别"><span class="toc-number">1.1.6.</span> <span class="toc-text">6.并发级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有关并行的两个重要定律"><span class="toc-number">1.1.7.</span> <span class="toc-text">有关并行的两个重要定律</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java的内存模型（JMM）"><span class="toc-number">1.1.8.</span> <span class="toc-text">java的内存模型（JMM）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java并行程序基础"><span class="toc-number">1.2.</span> <span class="toc-text">Java并行程序基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-线程的基本操作"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.线程的基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-volatile与Java内存模型-JMM"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.volatile与Java内存模型(JMM)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-线程组"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.线程组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-守护线程（Daemon）"><span class="toc-number">1.2.4.</span> <span class="toc-text">4.守护线程（Daemon）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-线程优先级"><span class="toc-number">1.2.5.</span> <span class="toc-text">5.线程优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-线程安全的概念与synchronized"><span class="toc-number">1.2.6.</span> <span class="toc-text">6.线程安全的概念与synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-隐蔽的错误"><span class="toc-number">1.2.7.</span> <span class="toc-text">7.隐蔽的错误</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK并发包"><span class="toc-number">2.</span> <span class="toc-text">JDK并发包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized的功能扩展：重入锁"><span class="toc-number">2.1.</span> <span class="toc-text">synchronized的功能扩展：重入锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-重入锁-使用java-util-concurrent-lock-ReentrantLock类来实现"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.重入锁,使用java.util.concurrent.lock.ReentrantLock类来实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-中断响应"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.中断响应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-锁申请等待限时"><span class="toc-number">2.1.3.</span> <span class="toc-text">3.锁申请等待限时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-公平锁"><span class="toc-number">2.1.4.</span> <span class="toc-text">4.公平锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重入锁的Condition条件"><span class="toc-number">2.2.</span> <span class="toc-text">重入锁的Condition条件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Condition接口提供方法"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.Condition接口提供方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-代码"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#允许多个线程同时访问：信号量（Semaphore）"><span class="toc-number">2.3.</span> <span class="toc-text">允许多个线程同时访问：信号量（Semaphore）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-构造信号量对象时，必须指定信号量的准入数，可以指定是否公平"><span class="toc-number">2.3.1.</span> <span class="toc-text">1.构造信号量对象时，必须指定信号量的准入数，可以指定是否公平</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-主要逻辑方法"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.主要逻辑方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-信号量的泄露"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.信号量的泄露</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReadWriteLock读写锁"><span class="toc-number">2.4.</span> <span class="toc-text">ReadWriteLock读写锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#倒计时器CountDownLatch"><span class="toc-number">2.5.</span> <span class="toc-text">倒计时器CountDownLatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#循环栅栏：CyclicBarrier"><span class="toc-number">2.6.</span> <span class="toc-text">循环栅栏：CyclicBarrier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程阻塞工具类：LockSupport"><span class="toc-number">2.7.</span> <span class="toc-text">线程阻塞工具类：LockSupport</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程复用：线程池"><span class="toc-number">2.8.</span> <span class="toc-text">线程复用：线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Executor框架"><span class="toc-number">2.8.1.</span> <span class="toc-text">1.Executor框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-拒绝策略"><span class="toc-number">2.8.2.</span> <span class="toc-text">2.拒绝策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义线程创建：ThreadFactory"><span class="toc-number">2.9.</span> <span class="toc-text">自定义线程创建：ThreadFactory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展线程池"><span class="toc-number">2.10.</span> <span class="toc-text">扩展线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK并发容器"><span class="toc-number">2.11.</span> <span class="toc-text">JDK并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-并发集合简介"><span class="toc-number">2.11.1.</span> <span class="toc-text">1.并发集合简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-线程安全的HashMap"><span class="toc-number">2.11.2.</span> <span class="toc-text">2.线程安全的HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-线程安全的List"><span class="toc-number">2.11.3.</span> <span class="toc-text">3.线程安全的List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-高效读写队列"><span class="toc-number">2.11.4.</span> <span class="toc-text">4.高效读写队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#锁优化与并行模式"><span class="toc-number">3.</span> <span class="toc-text">锁优化与并行模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#有助于提高”锁”性能的几点建议"><span class="toc-number">3.1.</span> <span class="toc-text">有助于提高”锁”性能的几点建议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-减少锁持有时间"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.减少锁持有时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-减少锁粒度"><span class="toc-number">3.1.2.</span> <span class="toc-text">2.减少锁粒度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-使用读写锁替换独占锁，之前介绍过，不再重复"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.使用读写锁替换独占锁，之前介绍过，不再重复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-锁分离"><span class="toc-number">3.1.4.</span> <span class="toc-text">4.锁分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-锁粗化"><span class="toc-number">3.1.5.</span> <span class="toc-text">5.锁粗化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java虚拟机对锁优化所做的努力"><span class="toc-number">3.2.</span> <span class="toc-text">Java虚拟机对锁优化所做的努力</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-锁偏向"><span class="toc-number">3.2.1.</span> <span class="toc-text">1.锁偏向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-轻量级锁"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.轻量级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-自旋锁"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-锁消除"><span class="toc-number">3.2.4.</span> <span class="toc-text">4.锁消除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">3.3.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#无锁"><span class="toc-number">3.4.</span> <span class="toc-text">无锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-说明："><span class="toc-number">3.4.1.</span> <span class="toc-text">0.说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-并发策略：比较交换（CAS）"><span class="toc-number">3.4.2.</span> <span class="toc-text">1.并发策略：比较交换（CAS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-无锁的线程安全整数：Atomiclnteger"><span class="toc-number">3.4.3.</span> <span class="toc-text">2.无锁的线程安全整数：Atomiclnteger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-无锁的对象引用：AtomicReferencece"><span class="toc-number">3.4.4.</span> <span class="toc-text">3.无锁的对象引用：AtomicReferencece</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-带有时间戳的对象引用：AtomicStampedReference"><span class="toc-number">3.4.5.</span> <span class="toc-text">4.带有时间戳的对象引用：AtomicStampedReference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-无锁的数组：AtomicIntegerArray"><span class="toc-number">3.4.6.</span> <span class="toc-text">5.无锁的数组：AtomicIntegerArray</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-普通变量的原子操作"><span class="toc-number">3.4.7.</span> <span class="toc-text">6.普通变量的原子操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-等待队列SynchronousQueue的实现"><span class="toc-number">3.4.8.</span> <span class="toc-text">7.等待队列SynchronousQueue的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#死锁"><span class="toc-number">3.5.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单例模式"><span class="toc-number">3.6.</span> <span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-包含静态成员的单例："><span class="toc-number">3.6.1.</span> <span class="toc-text">1.包含静态成员的单例：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-支持延迟加载的策略"><span class="toc-number">3.6.2.</span> <span class="toc-text">2.支持延迟加载的策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-无锁"><span class="toc-number">3.6.3.</span> <span class="toc-text">3.无锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不变模式"><span class="toc-number">3.7.</span> <span class="toc-text">不变模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-说明"><span class="toc-number">3.7.1.</span> <span class="toc-text">1.说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-只需注意"><span class="toc-number">3.7.2.</span> <span class="toc-text">2.只需注意</span></a></li></ol></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"【Java高并发程序设计】　| Just For Fun！　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    
        <section class="youyan" id="comments">
    <script>
        var loadComment = function(){
            var d = document, s = d.createElement('script');
            s.src = 'http://v2.uyan.cc/code/uyan.js?uid=2134263';
            (d.head || d.body).appendChild(s);
        }
    </script>
    
    <script> loadComment(); </script>

    <div id="uyan_frame"></div>
</section>
    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2017/03/12/【深入浅出MySQL】/" title="上一篇: 【深入浅出MySQL】">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2017/03/11/Java简单IO流操作/" title="下一篇: Java简单IO流操作">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/03/14/Redis(三、RDB和AOF介绍&企业级数据备份恢复方案)/">Redis(三、RDB和AOF介绍&企业级数据备份恢复方案)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/14/Redis(二、生产环境安装配置)/">Redis(二、生产环境安装配置)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/14/Redis(一、Mac安装配置使用redis)/">Redis(一、Mac安装配置使用redis)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/14/虚拟机安装配置4个节点集群/">虚拟机安装配置4个节点集群</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/14/Solr安装配置/">Solr安装配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/04/elasticsearch(四、索引管理)/">elasticsearch(四、索引管理)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/04/elasticsearch(三、内核知识)/">elasticsearch(三、内核知识)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/04/elasticsearch(二、搜索引擎)/">elasticsearch(二、搜索引擎)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/03/elasticsearch(一、核心概念和机制)/">elasticsearch(一、核心概念和机制)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/03/【Java8函数式编程】/">【Java8函数式编程】</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/03/Mysql存储引擎和事务/">Mysql存储引擎和事务</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/20/Java基础笔试题/">Java基础笔试题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/19/Java实现简单算法/">Java实现简单算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/19/Java实现简单树/">Java实现简单树</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/18/Java实现简单栈和队列/">Java实现简单栈和队列</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/18/Java实现简单线性表/">Java实现简单线性表</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/12/【深入浅出MySQL】/">【深入浅出MySQL】</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/12/【Java高并发程序设计】/">【Java高并发程序设计】</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/11/Java简单IO流操作/">Java简单IO流操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/09/Java常用对象/">Java常见对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/09/Java基本概念/">Java基本概念</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2018 fangminx
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>